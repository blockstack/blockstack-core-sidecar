/* tslint:disable */
/* eslint-disable */
/**
 * Stacks 2.0 Blockchain API
 * This is the documentation for the Stacks 2.0 Blockchain API.  It is comprised of two parts; the Stacks Blockchain API and the Stacks Core API.  [![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/614feab5c108d292bffa#?env%5BStacks%20Blockchain%20API%5D=W3sia2V5Ijoic3R4X2FkZHJlc3MiLCJ2YWx1ZSI6IlNUMlRKUkhESE1ZQlE0MTdIRkIwQkRYNDMwVFFBNVBYUlg2NDk1RzFWIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJibG9ja19pZCIsInZhbHVlIjoiMHgiLCJlbmFibGVkIjp0cnVlfSx7ImtleSI6Im9mZnNldCIsInZhbHVlIjoiMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfdHgiLCJ2YWx1ZSI6IjIwMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfYmxvY2siLCJ2YWx1ZSI6IjMwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJ0eF9pZCIsInZhbHVlIjoiMHg1NDA5MGMxNmE3MDJiNzUzYjQzMTE0ZTg4NGJjMTlhODBhNzk2MzhmZDQ0OWE0MGY4MDY4Y2RmMDAzY2RlNmUwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9pZCIsInZhbHVlIjoiU1RKVFhFSlBKUFBWRE5BOUIwNTJOU1JSQkdRQ0ZOS1ZTMTc4VkdIMS5oZWxsb193b3JsZFxuIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJidGNfYWRkcmVzcyIsInZhbHVlIjoiYWJjIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9hZGRyZXNzIiwidmFsdWUiOiJTVEpUWEVKUEpQUFZETkE5QjA1Mk5TUlJCR1FDRk5LVlMxNzhWR0gxIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9uYW1lIiwidmFsdWUiOiJoZWxsb193b3JsZCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWFwIiwidmFsdWUiOiJzdG9yZSIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWV0aG9kIiwidmFsdWUiOiJnZXQtdmFsdWUiLCJlbmFibGVkIjp0cnVlfV0=) 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BnsError,
    BnsErrorFromJSON,
    BnsErrorToJSON,
    BnsGetAllNamespacesResponse,
    BnsGetAllNamespacesResponseFromJSON,
    BnsGetAllNamespacesResponseToJSON,
    BnsGetNameInfoResponse,
    BnsGetNameInfoResponseFromJSON,
    BnsGetNameInfoResponseToJSON,
    BnsGetNamePriceResponse,
    BnsGetNamePriceResponseFromJSON,
    BnsGetNamePriceResponseToJSON,
    BnsGetNamespacePriceResponse,
    BnsGetNamespacePriceResponseFromJSON,
    BnsGetNamespacePriceResponseToJSON,
    BnsNamesOwnByAddressResponse,
    BnsNamesOwnByAddressResponseFromJSON,
    BnsNamesOwnByAddressResponseToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
} from '../models';

export interface FetchZoneFileRequest {
    name: string;
}

export interface GetAllNamesRequest {
    page: number;
}

export interface GetAllSubdomainsRequest {
    page: number;
}

export interface GetHistoricalZoneFileRequest {
    name: string;
    zoneFileHash: string;
}

export interface GetNameHistoryRequest {
    name: string;
    page: number;
}

export interface GetNameInfoRequest {
    name: string;
}

export interface GetNamePriceRequest {
    name: string;
}

export interface GetNamesOwnedByAddressRequest {
    blockchain: string;
    address: string;
}

export interface GetNamespaceNamesRequest {
    tld: string;
    page: number;
}

export interface GetNamespacePriceRequest {
    tld: string;
}

export interface GetSubdomainAtTransactionRequest {
    txid: string;
}

/**
 * BnsApi - interface
 * 
 * @export
 * @interface BnsApiInterface
 */
export interface BnsApiInterface {
    /**
     * 
     * @summary Fetch a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     * @param {string} name fully-qualified name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    fetchZoneFileRaw(requestParameters: FetchZoneFileRequest): Promise<runtime.ApiResponse<object>>;

    /**
     * Fetch a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     */
    fetchZoneFile(requestParameters: FetchZoneFileRequest): Promise<object>;

    /**
     * 
     * @summary Fetch a list of all names known to the node.
     * @param {number} page names are returned in pages of size 100, so specify the page number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getAllNamesRaw(requestParameters: GetAllNamesRequest): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * Fetch a list of all names known to the node.
     */
    getAllNames(requestParameters: GetAllNamesRequest): Promise<Array<string>>;

    /**
     * 
     * @summary Fetch a list of all namespaces known to the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getAllNamespacesRaw(): Promise<runtime.ApiResponse<BnsGetAllNamespacesResponse>>;

    /**
     * Fetch a list of all namespaces known to the node.
     */
    getAllNamespaces(): Promise<BnsGetAllNamespacesResponse>;

    /**
     * 
     * @summary Fetch a list of all subdomains known to the node.
     * @param {number} page names are returned in pages of size 100, so specify the page number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getAllSubdomainsRaw(requestParameters: GetAllSubdomainsRequest): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * Fetch a list of all subdomains known to the node.
     */
    getAllSubdomains(requestParameters: GetAllSubdomainsRequest): Promise<Array<string>>;

    /**
     * 
     * @summary Fetches the historical zonefile specified by the username and zone hash.
     * @param {string} name fully-qualified name
     * @param {string} zoneFileHash zone file hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getHistoricalZoneFileRaw(requestParameters: GetHistoricalZoneFileRequest): Promise<runtime.ApiResponse<object>>;

    /**
     * Fetches the historical zonefile specified by the username and zone hash.
     */
    getHistoricalZoneFile(requestParameters: GetHistoricalZoneFileRequest): Promise<object>;

    /**
     * 
     * @summary Get a history of all blockchain records of a registered name.
     * @param {string} name name to query
     * @param {number} page the page (in 20-entry pages) of the history to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNameHistoryRaw(requestParameters: GetNameHistoryRequest): Promise<runtime.ApiResponse<object>>;

    /**
     * Get a history of all blockchain records of a registered name.
     */
    getNameHistory(requestParameters: GetNameHistoryRequest): Promise<object>;

    /**
     * 
     * @summary Fetch name details.
     * @param {string} name fully-qualified name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNameInfoRaw(requestParameters: GetNameInfoRequest): Promise<runtime.ApiResponse<BnsGetNameInfoResponse>>;

    /**
     * Fetch name details.
     */
    getNameInfo(requestParameters: GetNameInfoRequest): Promise<BnsGetNameInfoResponse>;

    /**
     * 
     * @summary Get the price of a name. The `amount` given will be in the smallest possible units of the currency.
     * @param {string} name the name to query price information for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNamePriceRaw(requestParameters: GetNamePriceRequest): Promise<runtime.ApiResponse<BnsGetNamePriceResponse>>;

    /**
     * Get the price of a name. The `amount` given will be in the smallest possible units of the currency.
     */
    getNamePrice(requestParameters: GetNamePriceRequest): Promise<BnsGetNamePriceResponse>;

    /**
     * 
     * @summary Retrieves a list of names owned by the address provided.
     * @param {string} blockchain the layer-1 blockchain for the address
     * @param {string} address the address to lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNamesOwnedByAddressRaw(requestParameters: GetNamesOwnedByAddressRequest): Promise<runtime.ApiResponse<BnsNamesOwnByAddressResponse>>;

    /**
     * Retrieves a list of names owned by the address provided.
     */
    getNamesOwnedByAddress(requestParameters: GetNamesOwnedByAddressRequest): Promise<BnsNamesOwnByAddressResponse>;

    /**
     * 
     * @summary Fetch a list of names from the namespace.
     * @param {string} tld the namespace to fetch names from
     * @param {number} page names are returned in pages of size 100, so specify the page number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNamespaceNamesRaw(requestParameters: GetNamespaceNamesRequest): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * Fetch a list of names from the namespace.
     */
    getNamespaceNames(requestParameters: GetNamespaceNamesRequest): Promise<Array<string>>;

    /**
     * 
     * @summary Get the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     * @param {string} tld the namespace to fetch price for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getNamespacePriceRaw(requestParameters: GetNamespacePriceRequest): Promise<runtime.ApiResponse<BnsGetNamespacePriceResponse>>;

    /**
     * Get the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     */
    getNamespacePrice(requestParameters: GetNamespacePriceRequest): Promise<BnsGetNamespacePriceResponse>;

    /**
     * 
     * @summary Fetches the list of subdomain operations processed by a given transaction. The returned array includes subdomain operations that have not yet been accepted as part of any subdomain’s history (checkable via the accepted field). If the given transaction ID does not correspond to a Blockstack transaction that introduced new subdomain operations, and empty array will be returned.
     * @param {string} txid transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BnsApiInterface
     */
    getSubdomainAtTransactionRaw(requestParameters: GetSubdomainAtTransactionRequest): Promise<runtime.ApiResponse<Array<InlineResponse200>>>;

    /**
     * Fetches the list of subdomain operations processed by a given transaction. The returned array includes subdomain operations that have not yet been accepted as part of any subdomain’s history (checkable via the accepted field). If the given transaction ID does not correspond to a Blockstack transaction that introduced new subdomain operations, and empty array will be returned.
     */
    getSubdomainAtTransaction(requestParameters: GetSubdomainAtTransactionRequest): Promise<Array<InlineResponse200>>;

}

/**
 * 
 */
export class BnsApi extends runtime.BaseAPI implements BnsApiInterface {

    /**
     * Fetch a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     */
    async fetchZoneFileRaw(requestParameters: FetchZoneFileRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling fetchZoneFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/names/{name}/zonefile`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     */
    async fetchZoneFile(requestParameters: FetchZoneFileRequest): Promise<object> {
        const response = await this.fetchZoneFileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch a list of all names known to the node.
     */
    async getAllNamesRaw(requestParameters: GetAllNamesRequest): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getAllNames.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/names`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch a list of all names known to the node.
     */
    async getAllNames(requestParameters: GetAllNamesRequest): Promise<Array<string>> {
        const response = await this.getAllNamesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch a list of all namespaces known to the node.
     */
    async getAllNamespacesRaw(): Promise<runtime.ApiResponse<BnsGetAllNamespacesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BnsGetAllNamespacesResponseFromJSON(jsonValue));
    }

    /**
     * Fetch a list of all namespaces known to the node.
     */
    async getAllNamespaces(): Promise<BnsGetAllNamespacesResponse> {
        const response = await this.getAllNamespacesRaw();
        return await response.value();
    }

    /**
     * Fetch a list of all subdomains known to the node.
     */
    async getAllSubdomainsRaw(requestParameters: GetAllSubdomainsRequest): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getAllSubdomains.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/subdomains`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch a list of all subdomains known to the node.
     */
    async getAllSubdomains(requestParameters: GetAllSubdomainsRequest): Promise<Array<string>> {
        const response = await this.getAllSubdomainsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetches the historical zonefile specified by the username and zone hash.
     */
    async getHistoricalZoneFileRaw(requestParameters: GetHistoricalZoneFileRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getHistoricalZoneFile.');
        }

        if (requestParameters.zoneFileHash === null || requestParameters.zoneFileHash === undefined) {
            throw new runtime.RequiredError('zoneFileHash','Required parameter requestParameters.zoneFileHash was null or undefined when calling getHistoricalZoneFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/names/{name}/zonefile/{zoneFileHash}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"zoneFileHash"}}`, encodeURIComponent(String(requestParameters.zoneFileHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches the historical zonefile specified by the username and zone hash.
     */
    async getHistoricalZoneFile(requestParameters: GetHistoricalZoneFileRequest): Promise<object> {
        const response = await this.getHistoricalZoneFileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a history of all blockchain records of a registered name.
     */
    async getNameHistoryRaw(requestParameters: GetNameHistoryRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getNameHistory.');
        }

        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getNameHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/names/{name}/history`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a history of all blockchain records of a registered name.
     */
    async getNameHistory(requestParameters: GetNameHistoryRequest): Promise<object> {
        const response = await this.getNameHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch name details.
     */
    async getNameInfoRaw(requestParameters: GetNameInfoRequest): Promise<runtime.ApiResponse<BnsGetNameInfoResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getNameInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/names/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BnsGetNameInfoResponseFromJSON(jsonValue));
    }

    /**
     * Fetch name details.
     */
    async getNameInfo(requestParameters: GetNameInfoRequest): Promise<BnsGetNameInfoResponse> {
        const response = await this.getNameInfoRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the price of a name. The `amount` given will be in the smallest possible units of the currency.
     */
    async getNamePriceRaw(requestParameters: GetNamePriceRequest): Promise<runtime.ApiResponse<BnsGetNamePriceResponse>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getNamePrice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/prices/names/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BnsGetNamePriceResponseFromJSON(jsonValue));
    }

    /**
     * Get the price of a name. The `amount` given will be in the smallest possible units of the currency.
     */
    async getNamePrice(requestParameters: GetNamePriceRequest): Promise<BnsGetNamePriceResponse> {
        const response = await this.getNamePriceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves a list of names owned by the address provided.
     */
    async getNamesOwnedByAddressRaw(requestParameters: GetNamesOwnedByAddressRequest): Promise<runtime.ApiResponse<BnsNamesOwnByAddressResponse>> {
        if (requestParameters.blockchain === null || requestParameters.blockchain === undefined) {
            throw new runtime.RequiredError('blockchain','Required parameter requestParameters.blockchain was null or undefined when calling getNamesOwnedByAddress.');
        }

        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling getNamesOwnedByAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/addresses/{blockchain}/{address}`.replace(`{${"blockchain"}}`, encodeURIComponent(String(requestParameters.blockchain))).replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BnsNamesOwnByAddressResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of names owned by the address provided.
     */
    async getNamesOwnedByAddress(requestParameters: GetNamesOwnedByAddressRequest): Promise<BnsNamesOwnByAddressResponse> {
        const response = await this.getNamesOwnedByAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch a list of names from the namespace.
     */
    async getNamespaceNamesRaw(requestParameters: GetNamespaceNamesRequest): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.tld === null || requestParameters.tld === undefined) {
            throw new runtime.RequiredError('tld','Required parameter requestParameters.tld was null or undefined when calling getNamespaceNames.');
        }

        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling getNamespaceNames.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/namespaces/{tld}/names`.replace(`{${"tld"}}`, encodeURIComponent(String(requestParameters.tld))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch a list of names from the namespace.
     */
    async getNamespaceNames(requestParameters: GetNamespaceNamesRequest): Promise<Array<string>> {
        const response = await this.getNamespaceNamesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     */
    async getNamespacePriceRaw(requestParameters: GetNamespacePriceRequest): Promise<runtime.ApiResponse<BnsGetNamespacePriceResponse>> {
        if (requestParameters.tld === null || requestParameters.tld === undefined) {
            throw new runtime.RequiredError('tld','Required parameter requestParameters.tld was null or undefined when calling getNamespacePrice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/prices/namespaces/{tld}`.replace(`{${"tld"}}`, encodeURIComponent(String(requestParameters.tld))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BnsGetNamespacePriceResponseFromJSON(jsonValue));
    }

    /**
     * Get the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     */
    async getNamespacePrice(requestParameters: GetNamespacePriceRequest): Promise<BnsGetNamespacePriceResponse> {
        const response = await this.getNamespacePriceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetches the list of subdomain operations processed by a given transaction. The returned array includes subdomain operations that have not yet been accepted as part of any subdomain’s history (checkable via the accepted field). If the given transaction ID does not correspond to a Blockstack transaction that introduced new subdomain operations, and empty array will be returned.
     */
    async getSubdomainAtTransactionRaw(requestParameters: GetSubdomainAtTransactionRequest): Promise<runtime.ApiResponse<Array<InlineResponse200>>> {
        if (requestParameters.txid === null || requestParameters.txid === undefined) {
            throw new runtime.RequiredError('txid','Required parameter requestParameters.txid was null or undefined when calling getSubdomainAtTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/subdomains/{txid}`.replace(`{${"txid"}}`, encodeURIComponent(String(requestParameters.txid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse200FromJSON));
    }

    /**
     * Fetches the list of subdomain operations processed by a given transaction. The returned array includes subdomain operations that have not yet been accepted as part of any subdomain’s history (checkable via the accepted field). If the given transaction ID does not correspond to a Blockstack transaction that introduced new subdomain operations, and empty array will be returned.
     */
    async getSubdomainAtTransaction(requestParameters: GetSubdomainAtTransactionRequest): Promise<Array<InlineResponse200>> {
        const response = await this.getSubdomainAtTransactionRaw(requestParameters);
        return await response.value();
    }

}
