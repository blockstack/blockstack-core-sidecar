/* tslint:disable */
/* eslint-disable */
/**
 * Stacks 2.0 Blockchain API
 * This is the documentation for the Stacks 2.0 Blockchain API.  It is comprised of two parts; the Stacks Blockchain API and the Stacks Core API.  [![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/614feab5c108d292bffa#?env%5BStacks%20Blockchain%20API%5D=W3sia2V5Ijoic3R4X2FkZHJlc3MiLCJ2YWx1ZSI6IlNUMlRKUkhESE1ZQlE0MTdIRkIwQkRYNDMwVFFBNVBYUlg2NDk1RzFWIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJibG9ja19pZCIsInZhbHVlIjoiMHgiLCJlbmFibGVkIjp0cnVlfSx7ImtleSI6Im9mZnNldCIsInZhbHVlIjoiMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfdHgiLCJ2YWx1ZSI6IjIwMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfYmxvY2siLCJ2YWx1ZSI6IjMwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJ0eF9pZCIsInZhbHVlIjoiMHg1NDA5MGMxNmE3MDJiNzUzYjQzMTE0ZTg4NGJjMTlhODBhNzk2MzhmZDQ0OWE0MGY4MDY4Y2RmMDAzY2RlNmUwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9pZCIsInZhbHVlIjoiU1RKVFhFSlBKUFBWRE5BOUIwNTJOU1JSQkdRQ0ZOS1ZTMTc4VkdIMS5oZWxsb193b3JsZFxuIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJidGNfYWRkcmVzcyIsInZhbHVlIjoiYWJjIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9hZGRyZXNzIiwidmFsdWUiOiJTVEpUWEVKUEpQUFZETkE5QjA1Mk5TUlJCR1FDRk5LVlMxNzhWR0gxIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9uYW1lIiwidmFsdWUiOiJoZWxsb193b3JsZCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWFwIiwidmFsdWUiOiJzdG9yZSIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWV0aG9kIiwidmFsdWUiOiJnZXQtdmFsdWUiLCJlbmFibGVkIjp0cnVlfV0=)  ## Design  ### Stacks Core API vs Stacks Blockchain API The blockchain\'s Rust implementation exposes a JSON RPC endpoint (\"Stacks Core API\"), which can be used to interface with the blockchain. It can be used directly. [See the documentation for the `stacks-blockchain` in its Github repository](https://github.com/blockstack/stacks-blockchain/)  All `/v2/` routes a proxied to a Blockstack PBC-hosted Stacks Node. For a trustless architecture, you should make these requests to a self-hosted node.  All `/extended/` routes are provided by the Stacks 2.0 Blockchain API directly. They extend the Stacks Core API capabilities to make it easier to integrate with.  ### Pagination To make API responses more compact, lists returned by the API are paginated. For lists, the response body includes:    - `limit`: the number of list items return per response   - `offset`: the number of elements to skip (starting from `0`)   - `total`: the number of all available list items   - `results`: the array of list items (length of array equals the set limit)  Using the `limit` and `offset` properties, you can paginate through the entire list by increasing the offset by the limit until you reach the total.  ## Client Library A generated JS Client is available for consumption of this API. The client enables typesafe REST and WebSocket communication. Please review the [client documentation](https://blockstack.github.io/stacks-blockchain-api/client/index.html) for more details. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    RosettaAccountBalanceRequest,
    RosettaAccountBalanceRequestFromJSON,
    RosettaAccountBalanceRequestToJSON,
    RosettaAccountBalanceResponse,
    RosettaAccountBalanceResponseFromJSON,
    RosettaAccountBalanceResponseToJSON,
    RosettaBlockRequest,
    RosettaBlockRequestFromJSON,
    RosettaBlockRequestToJSON,
    RosettaBlockResponse,
    RosettaBlockResponseFromJSON,
    RosettaBlockResponseToJSON,
    RosettaBlockTransactionRequest,
    RosettaBlockTransactionRequestFromJSON,
    RosettaBlockTransactionRequestToJSON,
    RosettaBlockTransactionResponse,
    RosettaBlockTransactionResponseFromJSON,
    RosettaBlockTransactionResponseToJSON,
    RosettaConstructionDeriveRequest,
    RosettaConstructionDeriveRequestFromJSON,
    RosettaConstructionDeriveRequestToJSON,
    RosettaConstructionDeriveResponse,
    RosettaConstructionDeriveResponseFromJSON,
    RosettaConstructionDeriveResponseToJSON,
    RosettaConstructionHashRequest,
    RosettaConstructionHashRequestFromJSON,
    RosettaConstructionHashRequestToJSON,
    RosettaConstructionHashResponse,
    RosettaConstructionHashResponseFromJSON,
    RosettaConstructionHashResponseToJSON,
    RosettaConstructionMetadataRequest,
    RosettaConstructionMetadataRequestFromJSON,
    RosettaConstructionMetadataRequestToJSON,
    RosettaConstructionMetadataResponse,
    RosettaConstructionMetadataResponseFromJSON,
    RosettaConstructionMetadataResponseToJSON,
    RosettaConstructionParseRequest,
    RosettaConstructionParseRequestFromJSON,
    RosettaConstructionParseRequestToJSON,
    RosettaConstructionParseResponse,
    RosettaConstructionParseResponseFromJSON,
    RosettaConstructionParseResponseToJSON,
    RosettaConstructionPreprocessRequest,
    RosettaConstructionPreprocessRequestFromJSON,
    RosettaConstructionPreprocessRequestToJSON,
    RosettaConstructionPreprocessResponse,
    RosettaConstructionPreprocessResponseFromJSON,
    RosettaConstructionPreprocessResponseToJSON,
    RosettaConstructionSubmitRequest,
    RosettaConstructionSubmitRequestFromJSON,
    RosettaConstructionSubmitRequestToJSON,
    RosettaConstructionSubmitResponse,
    RosettaConstructionSubmitResponseFromJSON,
    RosettaConstructionSubmitResponseToJSON,
    RosettaError,
    RosettaErrorFromJSON,
    RosettaErrorToJSON,
    RosettaMempoolRequest,
    RosettaMempoolRequestFromJSON,
    RosettaMempoolRequestToJSON,
    RosettaMempoolResponse,
    RosettaMempoolResponseFromJSON,
    RosettaMempoolResponseToJSON,
    RosettaMempoolTransactionRequest,
    RosettaMempoolTransactionRequestFromJSON,
    RosettaMempoolTransactionRequestToJSON,
    RosettaMempoolTransactionResponse,
    RosettaMempoolTransactionResponseFromJSON,
    RosettaMempoolTransactionResponseToJSON,
    RosettaNetworkListResponse,
    RosettaNetworkListResponseFromJSON,
    RosettaNetworkListResponseToJSON,
    RosettaNetworkOptionsResponse,
    RosettaNetworkOptionsResponseFromJSON,
    RosettaNetworkOptionsResponseToJSON,
    RosettaOptionsRequest,
    RosettaOptionsRequestFromJSON,
    RosettaOptionsRequestToJSON,
    RosettaStatusRequest,
    RosettaStatusRequestFromJSON,
    RosettaStatusRequestToJSON,
} from '../models';

export interface RosettaAccountBalanceOperationRequest {
    rosettaAccountBalanceRequest: RosettaAccountBalanceRequest;
}

export interface RosettaBlockOperationRequest {
    rosettaBlockRequest: RosettaBlockRequest;
}

export interface RosettaBlockTransactionOperationRequest {
    rosettaBlockTransactionRequest: RosettaBlockTransactionRequest;
}

export interface RosettaConstructionDeriveOperationRequest {
    rosettaConstructionDeriveRequest: RosettaConstructionDeriveRequest;
}

export interface RosettaConstructionHashOperationRequest {
    rosettaConstructionHashRequest: RosettaConstructionHashRequest;
}

export interface RosettaConstructionMetadataOperationRequest {
    rosettaConstructionMetadataRequest: RosettaConstructionMetadataRequest;
}

export interface RosettaConstructionParseOperationRequest {
    rosettaConstructionParseRequest: RosettaConstructionParseRequest;
}

export interface RosettaConstructionPreprocessOperationRequest {
    rosettaConstructionPreprocessRequest: RosettaConstructionPreprocessRequest;
}

export interface RosettaConstructionSubmitOperationRequest {
    rosettaConstructionSubmitRequest: RosettaConstructionSubmitRequest;
}

export interface RosettaMempoolOperationRequest {
    rosettaMempoolRequest: RosettaMempoolRequest;
}

export interface RosettaMempoolTransactionOperationRequest {
    rosettaMempoolTransactionRequest: RosettaMempoolTransactionRequest;
}

export interface RosettaNetworkOptionsRequest {
    rosettaOptionsRequest: RosettaOptionsRequest;
}

export interface RosettaNetworkStatusRequest {
    rosettaStatusRequest: RosettaStatusRequest;
}

/**
 * 
 */
export class RosettaApi extends runtime.BaseAPI {

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalanceRaw(requestParameters: RosettaAccountBalanceOperationRequest): Promise<runtime.ApiResponse<RosettaAccountBalanceResponse>> {
        if (requestParameters.rosettaAccountBalanceRequest === null || requestParameters.rosettaAccountBalanceRequest === undefined) {
            throw new runtime.RequiredError('rosettaAccountBalanceRequest','Required parameter requestParameters.rosettaAccountBalanceRequest was null or undefined when calling rosettaAccountBalance.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/account/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaAccountBalanceRequestToJSON(requestParameters.rosettaAccountBalanceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaAccountBalanceResponseFromJSON(jsonValue));
    }

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalance(requestParameters: RosettaAccountBalanceOperationRequest): Promise<RosettaAccountBalanceResponse> {
        const response = await this.rosettaAccountBalanceRaw(requestParameters);
        return await response.value();
    }

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * Get a Block
     */
    async rosettaBlockRaw(requestParameters: RosettaBlockOperationRequest): Promise<runtime.ApiResponse<RosettaBlockResponse>> {
        if (requestParameters.rosettaBlockRequest === null || requestParameters.rosettaBlockRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockRequest','Required parameter requestParameters.rosettaBlockRequest was null or undefined when calling rosettaBlock.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockRequestToJSON(requestParameters.rosettaBlockRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockResponseFromJSON(jsonValue));
    }

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * Get a Block
     */
    async rosettaBlock(requestParameters: RosettaBlockOperationRequest): Promise<RosettaBlockResponse> {
        const response = await this.rosettaBlockRaw(requestParameters);
        return await response.value();
    }

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransactionRaw(requestParameters: RosettaBlockTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaBlockTransactionResponse>> {
        if (requestParameters.rosettaBlockTransactionRequest === null || requestParameters.rosettaBlockTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockTransactionRequest','Required parameter requestParameters.rosettaBlockTransactionRequest was null or undefined when calling rosettaBlockTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockTransactionRequestToJSON(requestParameters.rosettaBlockTransactionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockTransactionResponseFromJSON(jsonValue));
    }

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransaction(requestParameters: RosettaBlockTransactionOperationRequest): Promise<RosettaBlockTransactionResponse> {
        const response = await this.rosettaBlockTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDeriveRaw(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionDeriveResponse>> {
        if (requestParameters.rosettaConstructionDeriveRequest === null || requestParameters.rosettaConstructionDeriveRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionDeriveRequest','Required parameter requestParameters.rosettaConstructionDeriveRequest was null or undefined when calling rosettaConstructionDerive.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/derive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionDeriveRequestToJSON(requestParameters.rosettaConstructionDeriveRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionDeriveResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDerive(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<RosettaConstructionDeriveResponse> {
        const response = await this.rosettaConstructionDeriveRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHashRaw(requestParameters: RosettaConstructionHashOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionHashResponse>> {
        if (requestParameters.rosettaConstructionHashRequest === null || requestParameters.rosettaConstructionHashRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionHashRequest','Required parameter requestParameters.rosettaConstructionHashRequest was null or undefined when calling rosettaConstructionHash.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionHashRequestToJSON(requestParameters.rosettaConstructionHashRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionHashResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHash(requestParameters: RosettaConstructionHashOperationRequest): Promise<RosettaConstructionHashResponse> {
        const response = await this.rosettaConstructionHashRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadataRaw(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionMetadataResponse>> {
        if (requestParameters.rosettaConstructionMetadataRequest === null || requestParameters.rosettaConstructionMetadataRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionMetadataRequest','Required parameter requestParameters.rosettaConstructionMetadataRequest was null or undefined when calling rosettaConstructionMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/metadata`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionMetadataRequestToJSON(requestParameters.rosettaConstructionMetadataRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionMetadataResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadata(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<RosettaConstructionMetadataResponse> {
        const response = await this.rosettaConstructionMetadataRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParseRaw(requestParameters: RosettaConstructionParseOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionParseResponse>> {
        if (requestParameters.rosettaConstructionParseRequest === null || requestParameters.rosettaConstructionParseRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionParseRequest','Required parameter requestParameters.rosettaConstructionParseRequest was null or undefined when calling rosettaConstructionParse.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/parse`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionParseRequestToJSON(requestParameters.rosettaConstructionParseRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionParseResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParse(requestParameters: RosettaConstructionParseOperationRequest): Promise<RosettaConstructionParseResponse> {
        const response = await this.rosettaConstructionParseRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocessRaw(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionPreprocessResponse>> {
        if (requestParameters.rosettaConstructionPreprocessRequest === null || requestParameters.rosettaConstructionPreprocessRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPreprocessRequest','Required parameter requestParameters.rosettaConstructionPreprocessRequest was null or undefined when calling rosettaConstructionPreprocess.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/preprocess`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionPreprocessRequestToJSON(requestParameters.rosettaConstructionPreprocessRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionPreprocessResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocess(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<RosettaConstructionPreprocessResponse> {
        const response = await this.rosettaConstructionPreprocessRaw(requestParameters);
        return await response.value();
    }

    /**
     * Submit a pre-signed transaction to the node.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmitRaw(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionSubmitResponse>> {
        if (requestParameters.rosettaConstructionSubmitRequest === null || requestParameters.rosettaConstructionSubmitRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionSubmitRequest','Required parameter requestParameters.rosettaConstructionSubmitRequest was null or undefined when calling rosettaConstructionSubmit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/submit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionSubmitRequestToJSON(requestParameters.rosettaConstructionSubmitRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionSubmitResponseFromJSON(jsonValue));
    }

    /**
     * Submit a pre-signed transaction to the node.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmit(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<RosettaConstructionSubmitResponse> {
        const response = await this.rosettaConstructionSubmitRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all Transaction Identifiers in the mempool.
     * Get All Mempool Transactions
     */
    async rosettaMempoolRaw(requestParameters: RosettaMempoolOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolResponse>> {
        if (requestParameters.rosettaMempoolRequest === null || requestParameters.rosettaMempoolRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolRequest','Required parameter requestParameters.rosettaMempoolRequest was null or undefined when calling rosettaMempool.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolRequestToJSON(requestParameters.rosettaMempoolRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolResponseFromJSON(jsonValue));
    }

    /**
     * Get all Transaction Identifiers in the mempool.
     * Get All Mempool Transactions
     */
    async rosettaMempool(requestParameters: RosettaMempoolOperationRequest): Promise<RosettaMempoolResponse> {
        const response = await this.rosettaMempoolRaw(requestParameters);
        return await response.value();
    }

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransactionRaw(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolTransactionResponse>> {
        if (requestParameters.rosettaMempoolTransactionRequest === null || requestParameters.rosettaMempoolTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolTransactionRequest','Required parameter requestParameters.rosettaMempoolTransactionRequest was null or undefined when calling rosettaMempoolTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolTransactionRequestToJSON(requestParameters.rosettaMempoolTransactionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolTransactionResponseFromJSON(jsonValue));
    }

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransaction(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<RosettaMempoolTransactionResponse> {
        const response = await this.rosettaMempoolTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkListRaw(): Promise<runtime.ApiResponse<RosettaNetworkListResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/rosetta/v1/network/list`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkListResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkList(): Promise<RosettaNetworkListResponse> {
        const response = await this.rosettaNetworkListRaw();
        return await response.value();
    }

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptionsRaw(requestParameters: RosettaNetworkOptionsRequest): Promise<runtime.ApiResponse<RosettaNetworkOptionsResponse>> {
        if (requestParameters.rosettaOptionsRequest === null || requestParameters.rosettaOptionsRequest === undefined) {
            throw new runtime.RequiredError('rosettaOptionsRequest','Required parameter requestParameters.rosettaOptionsRequest was null or undefined when calling rosettaNetworkOptions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/options`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaOptionsRequestToJSON(requestParameters.rosettaOptionsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkOptionsResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptions(requestParameters: RosettaNetworkOptionsRequest): Promise<RosettaNetworkOptionsResponse> {
        const response = await this.rosettaNetworkOptionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatusRaw(requestParameters: RosettaNetworkStatusRequest): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters.rosettaStatusRequest === null || requestParameters.rosettaStatusRequest === undefined) {
            throw new runtime.RequiredError('rosettaStatusRequest','Required parameter requestParameters.rosettaStatusRequest was null or undefined when calling rosettaNetworkStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaStatusRequestToJSON(requestParameters.rosettaStatusRequest),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatus(requestParameters: RosettaNetworkStatusRequest): Promise<{ [key: string]: object; }> {
        const response = await this.rosettaNetworkStatusRaw(requestParameters);
        return await response.value();
    }

}
